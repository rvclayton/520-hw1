/// <reference path = "Coordinate.ts"/>
/// <reference path = "GridMove.ts"/>

// Dynamic programming.  A cell's cost is the length of the path from the cell
// to the goal.


class DPGridFrontier {


  add(states: DPGridState []): void {

    // this.printStack('p-queue before add():');
    // console.log('states.length = ' + states.length);

    for (var i = states.length - 1; i > -1; --i)
      this.stack.push(states[i]);

    // this.printStack('p-queue after add():');
    }
    

  constructor(start: DPGridState) {
    this.stack = [ start ];
    }


  empty(): boolean {
    return this.stack.length == 0;
    }
    

  nextState(): DPGridState {
    // this.printStack('p-queue before nextState():');

    if (this.empty())
      throw "calling nextState() on an empty frontier";
    else {
      var s = this.stack.shift();
      // this.printStack('p-queue after nextState():');
      return s;
      }
    }


  private printStack(label: string) {
    console.log(label);
    for (var i = 0 ; i < this.stack.length; ++i)
      console.log('  ' + this.stack[i].toString());
    }


  private stack: DPGridState [];
  }



class DPGridProblem {

  private allNeighbors(s: DPGridState): DPGridState [] {

    // Return an array containing all the neighbors (valid and invalid) of the
    // given state.

    var n: DPGridState [] = [ ];
    var moves = [ GridMove.up, GridMove.left, GridMove.right, GridMove.down ];
    
    for (var d in moves)
      n.push(DPGridState.new(s, d));

    return n;    
    }


  constructor(
    private start: Coordinate,
    private goal: Coordinate,
    private obstructions: Coordinate [],
    private rows: number,
    private cols: number) {

    this.g = new DPGridState(goal);
    }


  goalState(): DPGridState {
    return this.g;
    }


  isGoalState(s: DPGridState): boolean {
    return this.g == s;
    }


  private
  manhattanDistance(s1: DPGridState, s2: DPGridState): number {

    var c1 = s1.coordinate()
    var c2 = s2.coordinate()

    return Math.abs(c1.x() - c2.x()) + Math.abs(c1.y() - c2.y())
    }


  neighbors(s: DPGridState): DPGridState [] {

    if (!this.validState(s))
      throw new Error("invalid state in neighbors()");

    // console.log('Neighbors of ' + s.coordinate().toString());

    return this.validNeighbors(s, this.allNeighbors(s));
    }


  private
  setCost(s: DPGridState): DPGridState {

    s.setCost(this.manhattanDistance(s, this.goalState()));

    return s;
    }


  startState(): DPGridState {

    // Return this problem's start state.

    return DPGridState.new(this.start);
    }


  private
  validNeighbors(
    state: DPGridState, neighbors: DPGridState []): DPGridState [] {

    // Return a list of the valid states in the given list of neighbors of
    // the given state.
    
    var n: DPGridState [] = [ ];

    for (var i = neighbors.length - 1; i > -1; --i) {
      var s: DPGridState = neighbors[i];
      if (this.validState(s)) {
        n.push(this.setCost(s));
        // console.log('  ' + s.coordinate().toString());
	}
      }	

    return n;
    }


  private validState(child: DPGridState): boolean {

    var c = child.coordinate();

    var x = c.x();
    if ((x < 0) || (x >= this.rows))
      return false;
      
    var y = c.y();
    if ((y < 0) || (y >= this.cols))
      return false;
      
    for (var i = this.obstructions.length - 1; i > -1; --i)
      if (this.obstructions[i].equal(c))
        return false;

    return true;
    }

  private g: DPGridState;
  }

  
class DPGridState {


  /* private */ constructor(c: Coordinate) {

    // This constructor shouldn't be called outside this class.  Use the
    // DPGridState.new() factory instead.

    this.c = c;
    }


  coordinate(): Coordinate {
    return this.c;
    }
    

  cost(): number {
    return this.cst;
    }
    

  equal(s: any): boolean {
    return s.coordinate().equal(this.c);
    }


  private static label(c: Coordinate): string {
    return c.x().toString() + '.' + c.y().toString();
    }


  move(): GridMove {
    return this.m;
    }


  static new(source: any, m?: GridMove) {

    // Return the state associated with a coordinate.  If source is a
    // coordinate, m should be undefined. If source is a state, them m should
    // be defined and the state returned is the one associated with the
    // coordinate generated by applying m to source's coordinate.
    //
    // Each coordinate exactly one associated state, and that state is always
    // returned when given the associated coordinate.  In other words:
    //   s1.coordinate().equal(s2.coordinate()) <=> s2 = s1
    
    var c: Coordinate;
    
    if (m == undefined)
      c = source;
    else {
      c = source.coordinate();
      var x = c.x();
      var y = c.y();

      if (m == GridMove.up)
        c = new Coordinate(x, y + 1);
      else if (m == GridMove.left)
        c = new Coordinate(x - 1, y);
      else if (m == GridMove.right)
        c = new Coordinate(x + 1, y);
      else if (m == GridMove.down)
        c = new Coordinate(x, y - 1);
      else 
        throw new Error("unrecognized grid move in new DPGridState()");
      }

    var l = DPGridState.label(c);
    var s: DPGridState = DPGridState.cache[l];

    if (s == undefined) {
      s = new DPGridState(c);
      if (m != undefined) {
        s.p = source;
	s.m = m;
        }
      DPGridState.cache[l] = s;
      // console.log('cache ' + s.toString() + ' at ' + l);
      }

    return s;
    }


  parent(): DPGridState {
    return this.p;
    }


  static reset(): void {
    DPGridState.cache = { };
    }


  setCost(c: number): void {
    if (this.cst != undefined)
      throw new Error(
        "trying to reset a state " + this.toString() + "'s cost");
    this.cst = c;
    }


  toString(): string {

    var msg = '{ ' + this.c.toString();

    if (this.m != undefined)
      msg = msg + ', ' + GridMove[this.m] + ', {' + this.p.c.toString() + '}';
      
    if (this.cst != undefined)
      msg = msg + ', ' + this.cst;

    return msg + ' }';
    }

    
  private p: DPGridState;
  private m: GridMove;
  private cst: number;
  private c: Coordinate;
  
  private static cache = { };
  }


function
DPGridSolver(p: DPGridProblem, grid): DPGridState {

  var s = p.startState();
  var f: DPGridFrontier = new DPGridFrontier(s);

  var setCosts = function(): void {

    var setCost = function(s: DPGridState, c: number): void {
      s.setCost(c);
      grid.valueCell(s.coordinate(), c);
      }
      
    setCost(s, 0);
    
    do {
      s = f.nextState();
      var c = s.cost() + 1;    
      var neighbors = p.neighbors(s);

      while (neighbors.length > 0) {
	var n = neighbors.pop();
	if (n.cost() == undefined || n.cost() > c)
	  setCost(n, c);
	  f.add([n]);
	  }
      }
    while (!f.empty());
    };

  var tracePath = function(s: DPGridState): DPGridState {

    var g = p.goalState();
    var pathLength = 0;

    var minCost = function(states: DPGridState []): DPGridState {

      var minState = states[0];
      
      for (var i = states.length - 1; i > 0; --i)
        if (minState.cost() > states[i].cost())
	  minState = states[i];

      return minState;
      }

    while ((s != undefined) && p.isGoalState(s)) {
      grid.numberCell(s.coordinate().x(), s.coordinate().y(), pathLength++);
      s = minCost(p.neighbors(s));
      }

    if (s == g)
      grid.numberCell(s.coordinate().x(), s.coordinate().y(), pathLength);
      
    return s;
    };
    
  setCosts();
  
  return tracePath(p.startState());
  };
