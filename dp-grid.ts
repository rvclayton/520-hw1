/// <reference path = "Coordinate.ts"/>
/// <reference path = "GridMove.ts"/>

// Dynamic programming.  A cell's cost is the length of the path from the cell
// to the goal.


class
DPGridFrontier {


  add(states: DPGridState []): void {

    // this.printStack('frontier before add():');
    // console.log('states.length = ' + states.length);

    for (var i = states.length - 1; i > -1; --i)
      this.stack.push(states[i]);

    // this.printStack('frontier after add():');
    }
    

  constructor(start: DPGridState) {
    // console.log('start frontier with ' + start.toString());
    this.stack = [ start ];
    }


  empty(): boolean {
    return this.stack.length == 0;
    }
    

  nextState(): DPGridState {
    // this.printStack('frontier before nextState():');

    if (this.empty())
      throw "calling nextState() on an empty frontier";
    else {
      var s = this.stack.shift();
      // this.printStack('frontier after nextState():');
      return s;
      }
    }


  private printStack(label: string) {
    console.log(label);
    for (var i = 0 ; i < this.stack.length; ++i)
      console.log('  ' + this.stack[i].toString());
    }


  private stack: DPGridState [];
  }



class
DPGridProblem {

  private
  allNeighbors(s: DPGridState): DPGridState [] {

    // Return an array containing all the neighbors (valid and invalid) of the
    // given state.

    var n: DPGridState [] = [ ];
    var moves = [ GridMove.up, GridMove.left, GridMove.right, GridMove.down ];
    
    for (var d in moves)
      n.push(DPGridState.new(s, d));

    return n;    
    }


  constructor(
    private start: Coordinate,
    private goal: Coordinate,
    private obstructions: Coordinate [],
    private rows: number,
    private cols: number) {
    }


  goalState(): DPGridState {
    return new DPGridState(this.goal);
    }


  isGoalState(s: DPGridState): boolean {
    return this.goal.equal(s.coordinate());
    }


  neighbors(s: DPGridState): DPGridState [] {

    if (!this.validState(s))
      throw new Error("invalid state in neighbors()");

    // console.log('Neighbors of ' + s.coordinate().toString());

    return this.validNeighbors(s, this.allNeighbors(s));
    }


  startState(): DPGridState {

    // Return this problem's start state.

    return DPGridState.new(this.start);
    }


  private
  validNeighbors(
    state: DPGridState, neighbors: DPGridState []): DPGridState [] {

    // Return a list of the valid states in the given list of neighbors of
    // the given state.
    
    var n: DPGridState [] = [ ];

    for (var i = neighbors.length - 1; i > -1; --i) {

      var s: DPGridState = neighbors[i];

      // If a neighbor has a defined cost, then there's a shorter path to the
      // neighbor and it should be (multi-path) pruned.

      if (this.validState(s) && (s.cost() == undefined)) {
        n.push(s);
        // console.log('  ' + s.coordinate().toString());
	}
      }	

    return n;
    }


  private
  validState(child: DPGridState): boolean {

    var c = child.coordinate();

    var x = c.x();
    if ((x < 0) || (x >= this.rows))
      return false;
      
    var y = c.y();
    if ((y < 0) || (y >= this.cols))
      return false;
      
    for (var i = this.obstructions.length - 1; i > -1; --i)
      if (this.obstructions[i].equal(c))
        return false;

    return true;
    }
  }

  
class
DPGridState {


  /* private */
  constructor(c: Coordinate) {

    // This constructor shouldn't be called outside this class.  Use the
    // DPGridState.new() factory instead.

    this.c = c;
    // console.log('construct ' + this.toString());
    }


  coordinate(): Coordinate {
    return this.c;
    }
    

  cost(): number {
    return this.cst;
    }
    

  equal(s: any): boolean {
    return s.coordinate().equal(this.c);
    }


  private static
  label(c: Coordinate): string {
    return c.x().toString() + '.' + c.y().toString();
    }


  move(): GridMove {
    return this.m;
    }


  static
  new(source: any, m?: GridMove) {

    // Return the state associated with a coordinate.  If source is a
    // coordinate, m should be undefined. If source is a state, them m should
    // be defined and the state returned is the one associated with the
    // coordinate generated by applying m to source's coordinate.
    //
    // Each coordinate exactly one associated state, and that state is always
    // returned when given the associated coordinate.  In other words:
    //   s1.coordinate().equal(s2.coordinate()) <=> s2 = s1
    
    var c: Coordinate;
    
    if (m == undefined)
      c = source;
    else {
      c = source.coordinate();
      var x = c.x();
      var y = c.y();

      if (m == GridMove.up)
        c = new Coordinate(x, y + 1);
      else if (m == GridMove.left)
        c = new Coordinate(x - 1, y);
      else if (m == GridMove.right)
        c = new Coordinate(x + 1, y);
      else if (m == GridMove.down)
        c = new Coordinate(x, y - 1);
      else 
        throw new Error("unrecognized grid move in new DPGridState()");
      }

    var l = DPGridState.label(c);
    var s: DPGridState = DPGridState.cache[l];

    if (s == undefined) {
      s = new DPGridState(c);
      if (m != undefined) {
        s.p = source;
	// console.log(s.toString() + " -> " + source.toString());
	s.m = m;
        }
      DPGridState.cache[l] = s;
      // console.log('cache ' + s.toString() + ' at ' + l);
      }

    return s;
    }


  parent(): DPGridState {
    return this.p;
    }


  static reset(): void {
    DPGridState.cache = { };
    }


  setCost(c: number): void {
    if (this.cst != undefined)
      throw new Error(
        "trying to reset a state " + this.toString() + "'s cost");
    this.cst = c;
    }


  toString(): string {

    var msg = '{ ' + this.c.toString();

    if (this.m != undefined)
      msg = msg + ', ' + GridMove[this.m] + ', {' + this.p.c.toString() + '}';
      
    if (this.cst != undefined)
      msg = msg + ', c: ' + this.cst;

    return msg + ' }';
    }

    
  private p: DPGridState;
  private m: GridMove;
  private cst: number;
  private c: Coordinate;
  
  private static cache = { };
  }


function
DPGridSolver(p: DPGridProblem, grid): DPGridState {

  var setCosts = function(s: DPGridState): void {

    var f: DPGridFrontier = new DPGridFrontier(s);

    var setCost = function(s: DPGridState, c: number): void {
      // console.log('set cost for ' + s.toString() + ' to ' + c);
      s.setCost(c);
      grid.valueCell(s.coordinate(), c);
      }
      
    setCost(s, 0);
    
    do {
      s = f.nextState();
      var c = s.cost() + 1;    
      var neighbors = p.neighbors(s);

      while (neighbors.length > 0) {
	var n = neighbors.pop();
	// console.log('neighbor is ' + n.toString());
	setCost(n, c);
	f.add([n]);
        } 
      }
    while (!f.empty());
    };

  var tracePath = function(start: DPGridState): void {

    var stateCount = 0;
    var s;
    
    for (s = start ; s != undefined; s = s.parent())
      ++stateCount;

    for (s = start ; s != undefined; s = s.parent())
      grid.numberCell(s.coordinate().x(), s.coordinate().y(), stateCount--);
    };
    
  DPGridState.reset();
  
  setCosts(p.goalState());
  if (p.startState().cost() != undefined)
    tracePath(p.startState());

  if (p.startState().cost() == undefined)
    return undefined;
  else
    return p.startState();
  };
